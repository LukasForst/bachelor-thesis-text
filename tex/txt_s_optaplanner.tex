\section{Load balancing decisions with OptaPlanner}\label{sec:load-balancing-optaplanner}

Scheduling system implementation uses OptaPlanner library core in version \inlinedata{7.19.0.Final}\cite{optaplannerDoc}
and it is crucial part of the \inlinecode{core} module and application itself.

\subsection{Scheduling Algorithm}
The OptaPlanner scheduling itself has two main phases.
\textit{Construction heuristics}, that tries to build initial solution in a finite length of time.
This partial solution is not always feasible, 
but it is found in relatively short time and then it is passed to the next scheduling phase.
\textit{Local search} with metaheuristics that can enhance the partial solution found in previous phase.

OptaPlanner contains various types of construction heuristics (i.e. \textit{first fit}, \textit{weakest fit} and \textit{strongest fit})
as well as local search metaheuristics such as \textit{hill climbing}, \textit{tabu search} and \textit{simulated annealing}.
As the best combination of construction heuristics and local search proved to be \textit{first fit} with \textit{tabu search}.

The First Fit algorithm cycles through all the planning entities,
initializing one planning entity at a time. 
It assigns the planning entity to the best available planning value, 
taking the already initialized planning entities into account.
It terminates when all entities have been initialized\cite{optaplannerDoc:heuristics}.

The Tabu Search metaheuristics search is based on local search optimization method
and enhances it by worse step strategy, 
when at each step worsening moves can be accepted if no improving move is available.
In addition, prohibitions are introduced to discourage the search from coming back to previously-visited solutions\cite{glover1989tabu}.

\subsection{Formalized definition representation}\label{subsec:formalized-definition-representation}
In this section,
I would like to provide mapping between formalized problem definition described in section \ref{sec:formal-definition}
and actual implementation in code.

Each job, which is indexed in definition as $j$,
implements \inlinecode{Job} interface 
and effectively in core representation it is \inlinecode{PlanningJob} class which is being scheduled.
Input variables $D^{j}$ and $P^{j}$ are specified as \inlinecode{JobParameters} property of \inlinecode{Job} interface.

Resources $r$ are implemented as sealed class \inlinecode{Resources} composing of \inlinecode{CpuResources} and \inlinecode{MemoryResources}.
Resources belong to resources pools,
which can be imagined as physical computers or virtual machines.
Resource pools then cary information about cost ${}^{r}c$ of underlying resources.
The pools are represented as \inlinecode{ResourcesPool} interface with corresponding implementation classes.

Job value during time $v_{t}^{j}$ is implemented as \inlinecode{JobValue}
and belongs to interface \inlinecode{JobWithHistory},
that describes any job,
that has some historical information (like job value development and scheduling data).
Job value related information uses \inlinecode{AssignmentsEvaluation} during scheduling to compute reward for scheduler with value $S_{t}^{j}$.

Resources cost $C_{t}^{j}$ value is used in cost constraint \inlinecode{CostEvaluation} for comparison with $P^{j}$.
In similar constraint \inlinecode{TimeEvaluation}, $t$ value is compared with $D^{j}$ to check whether all specified constraints are satisfied.

Scheduling output is always \inlinecode{AllocationPlan}.
It contains job domain, resources domain, overall cost
and created time schedule.
From the latest, 
values $T^{j}$ and $C^{j}$ can be computed very easily,
therefore are not present directly in interface as properties.

\subsection{Implementation}
Whole scheduling implementation can be found in module \inlinecode{core}.
Moreover, 
constraints are placed in package \inlinecode{pw.forst.olb.core.constraints}.
OptaPlanner related implementation is placed inside \inlinecode{pw.forst.olb.core.domain}
and plan solution evaluator in \inlinecode{pw.forst.olb.core.evaluation}.

All custom constraints should implement \inlinecode{CompletePlanEvaluation} 
or \inlinecode{PlanEvaluation} interface.
That way, 
they can be used in custom score evaluator,
which is then used to generate score of the given plan.
The constrains are stored in collections of previously mentioned interfaces 
and evaluated at once, when plan is submitted.
Thanks to this solution,
additional constrains can be added or removed very easily.

As an input for the scheduling algorithm interface \inlinecode{SchedulingProperties} is used.
This interface defines properties necessary for the scheduling infrastructure
such as \inlinecode{maxTimePlanningSpend} which defines how long can the application run the scheduling 
or \inlinecode{cores}, describing how many cores in the computer can algorithm utilize by spawning scheduling threads.

The OptaPlanner scheduler instance is created by custom factory implementation 
\inlinecode{OptaPlannerSolverFactory} and uses base configuration defined in \inlinedata{solverConfiguration.xml} file.
