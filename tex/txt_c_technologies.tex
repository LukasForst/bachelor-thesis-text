%%
%% Author: lukas
%% 03.01.2019
%%

\chapter{Implementation}\label{ch:used-technologies}
In this section I would like to mention related technologies that could be potentially used while implementing described RMS\@.

\section{Architecture}
Something about whole architecture of the application, microservices and stuff
also add some image of architecture
\subsubsection{Microservices}
pros/cons of microservices architecture in overall and my implementation

\subsubsection{Design}
packages structure, some figures with architecture visualisation

\section{Related and used technologies}\label{sec:related-technologies}
General information about used technologies.

\subsection{Java platform}\label{subsec:tech-java}
general info about java programming language and java paltform

\subsection{Docker}\label{subsec:tech-docker}
general info about docker 

\subsection{Gradle}\label{subsec:tech-gradle}
general info about gradle

\section{Development stack}\label{sec:development-stack}
Definition of development stack
Add that target environment is JVM 11 but it has backwards compatibility to Java 8.

\subsection{Programming Language}\label{subsec:programming-language}
Superior Kotlin something

\subsection{Build environment}
As a build automation system I used Gradle, 
which is high performance choice mainly because its incrementally build system,
that works by tracking input and output of tasks, 
including files changes tracking, and only running tasks, that are necessary. 
Also, it processes only these files, that were changed between tasks execution. 
Another reason I choose Gradle was, that it is preferred build system for Kotlin.

To keep build clean and reusable on almost every operating system and 
machine setup I decided to use \textbf{multistage Docker\todo{add link to docker label} builds}
which uses different base docker images for the build and for the run phase.

\subsubsection{Docker build environment}
Since OLB targets JVM 11 environment and uses Gradle as its build system,
\textit{gradle:5.4.0-jdk11-slim} is used as base image for build stage.
This image contains all necessary Gradle build tools while having smaller size than common Gradle Docker image.
Even smaller (in terms of size) are \textit{alpine} based docker images. 
Alpine is smallest possible Linux core, 
which is widely used in wide range of Docker base images.
Alpine is focused on the smallest possible size of the image, 
while having all necessary tools build in.
Unfortunately, there were (at the time of development) no official JVM 11 alpine images
since there is no official stable OpenJDK\footnote{Open-source implementation of the Java Platform, Standard Edition} 
11 build for Alpine Linux.

\subsection{Runtime environment}
There are multiple ways, how to start and run the application on the local machine.
\begin{itemize}
    \item As a container inside Docker system - \textbf{preferred}
    \item Locally on JVM 11
    \item Locally on the older JVM (but at least JVM 8)
\end{itemize}

The preferred runtime environment is Docker system, 
where application image runs inside the created docker container,
this is described in the next subsection.\todo{add ref to label}

Although this is preferred execution approach,
there are few other approaches,
how to start and run the application.

It is possible to start the application locally (without Docker environment) by having JVM installed directly on the machine.
Published application setup targets JVM 11, 
therefore for the successful application execution there must be present latest version of JVM 11.

However,
it is also possible to run the application on the previous versions of the JVM up to JVM 8.
Using this way of application execution means,
that it must be build directly under local JVM 8 using the Gradle build system.

\subsubsection{Docker runtime environment}\label{subsubsec:docker-runtime-env}
The build application files are copied from the Docker build stage to the Docker runtime stage.
As the runtime base image in multistage build was used \textit{openjdk:11-jre-slim} image,
because it is official OpenJDK 11 Docker image and therefore it is declared as stable.

Because there was used \textit{gradle application plugin} while building the application, 
startup scripts were generated by the Gradle.
These scripts are then used to start the application itself inside the Docker container.

When starting the whole application, 
multiple services must be started up.
Therefore, because of the containerized environment,
where containers can not access each other,
multiple containers must be started and virtual network connecting them together must be created.
This process can be automated using Docker Compose.

\subsubsection{Docker Compose}
something about docker-compose

\section{Framework}
KTor something

\subsubsection{Route discovery library}
My developed library for route discovery for KTro

\section{Algorithm value prediction}\label{sec:algorithm-value-prediction}

Used library - https://github.com/finmath/finmath-lib

\section{Load balancing decisions}\label{sec:load-balancing-decisions}

Used library - https://www.optaplanner.org/

\section{Build and deployment}\label{sec:build-and-deployment}
Info how to build everything and how to deploy it to the AWS for example.